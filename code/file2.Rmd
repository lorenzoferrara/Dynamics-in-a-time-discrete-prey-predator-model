---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

```{r eval=FALSE, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	cache = TRUE,
	fig.align = "center",
	warning = FALSE,
	out.width = "70%",
	tidy = TRUE,
	tidy.opts = list(width.cutoff = 60)
)
```

```{r BASE TOOLS, warning=FALSE}
library(maptools)
library(spatstat)

rm(list=ls())
# setwd("C:/Users/lofer/Dropbox/POLI/quantitative/paper")

mu = 0.7
beta = 2.5
gamma = 5

T = function(vector){
  x=vector[1]
  y=vector[2]
  z=vector[3]
  temp=c( mu*x*(1-x-y-z),
          beta*y*(x-z),
          gamma*y*z)
  for(i in 1:3){
    if(temp[i]<0)
    temp[i]=0
  }
  return(temp)
}

is.outside = function(vector){
  x=vector[1]
  y=vector[2]
  z=vector[3]
  if(x<0 | y<0 | z<0 | x+y+z>1)
    return(1)
  return(0)
}

distance = function(vec1, vec2){
  return( sqrt( sum( (vec1-vec2)^2 ) ) )
}

is.converged = function(vector, mu, beta, gamma){
  
  fixed.points = list( c(0,0,0), c((mu-1)/mu, 0, 0), c(1/beta, 1-1/mu-1/beta, 0) )

  if( distance(vector, fixed.points[[1]]) < 1e-4)
    return(1)
  if( distance(vector, fixed.points[[2]]) < 1e-4)
    return(2)
  if( distance(vector, fixed.points[[3]]) < 1e-4)
    return(3)
  return(0)
}

{
N=200
valori.x = (1:N)/N
valori.z = valori.x
}

```


```{R }
num_iterazioni=50
```


Plot population behavior
```{r}
mu=0.7
beta=1.5
gamma=5

y0=0

grid.4 = matrix(NA, N, N)
for (i in 1:N) {
  for (j in 1:(N+1-i)) {
    series=c(i/N, y0, j/N)

    for (n in 1:num_iterazioni) {
      series=T(series)
      temp = is.converged(series, mu, beta, gamma) 
      if( temp ){
        break
      }
    }
    grid.4[i,j]=temp
  }
  cat(i/N*100, "%  ")
}
```


```{r}
mycolours= c("blue", "green", "red", "orange")

grafico<-im(t(grid.4),valori.x,valori.z)
# plot(grafico,axis=T, main=paste("mu=",mu, " and beta=", beta, sep=""), col=c("green", "red"))
plot(grafico,axis=T, main=paste("mu=",mu, " and beta=", beta, sep=""), col=mycolours, show.all=T)
```

```{r}
mu=0.7
beta=1.5
gamma=5

y0=0.2

grid.5 = matrix(NA, N, N)
for (i in 1:N) {
  for (j in 1:(N+1-i)) {
    series=c(i/N, y0, j/N)

    for (n in 1:num_iterazioni) {
      series=T(series)
      temp = is.converged(series, mu, beta, gamma) 
      if( temp ){
        break
      }
    }
    grid.5[i,j]=temp
  }
  cat(i/N*100, "%  ")
}
```


```{r}

ok = as.SpatialGridDataFrame.im(grafico)
image(ok,  )
```

```{r}
mycolours= c("blue", "green", "red", "orange")

grafico<-im(t(grid.5),valori.x,valori.z)
# plot(grafico,axis=T, main=paste("mu=",mu, " and beta=", beta, sep=""), col=c("green", "red"))
plot(grafico,axis=T, main=paste("mu=",mu, " and beta=", beta, sep=""), col=mycolours, show.all=T)
```
Plot population behavior
```{R}
mu=3.5
beta=4.5

grid.2 = matrix(NA, N, N)
for (i in 1:N) {
  for (j in 1:(N+1-i)) {
    series=c(i/N, j/N, 0)    # x=i/N, y=j/N

    for (n in 1:num_iterazioni) {
      series=T(series)
      if( is.outside(series) ){
        break
      }
    }
    grid.2[i,j]=n
  }
  # cat(i/N*100, "%  ")
}
```

```{r}
grafico<-im(t(grid.2),valori.x,valori.z)
plot(grafico,axis=T, main=paste("mu=",mu, " and beta=", beta, sep=""))
```

Plot population behavior
```{R}
mu=2.5
beta=5

grid.3 = matrix(NA, N, N)
for (i in 1:N) {
  for (j in 1:(N+1-i)) {
    series=c(i/N, j/N, 0)    # x=i/N, y=j/N

    for (n in 1:num_iterazioni) {
      series=T(series)
      if( is.outside(series) ){
        break
      }
    }
    grid.3[i,j]=n
  }
  # cat(i/N*100, "%  ")
}
```

```{r}
grafico<-im(mat = t(grid.3),xcol = valori.x, yrow = valori.z)
plot(grafico,axis=T, main=paste("mu=",mu, " and beta=", beta, sep=""))
```

```{r}
save.image(".RData")
```

```{r}
i=10
j=20
series=c(i/N, y0, j/N)

for (n in 1:num_iterazioni){
  series=T(series)
  cat(series, ": ", is.converged(series, mu, beta, gamma), "\n" )
}
```




